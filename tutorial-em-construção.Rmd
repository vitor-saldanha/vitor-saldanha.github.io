---
title: "Tutorial em Constru√ß√£o"
description: |
  Tutorial em Constru√ß√£o em R.
output:
  distill::distill_article:
    highlight: pygments
    highlight_downlit: false
---

```{css, echo = F}
/* Estilo para a caixa de c√≥digo */
d-article pre {
background-color: #f6f8fa !important;  /* O !important for√ßa a mudan√ßa da cor */
border: 1px solid #e1e4e8 !important;  /* For√ßa a borda */
border-radius: 6px;        /* Cantos arredondados */
padding: 12px;             /* Espa√ßo interno para o texto n√£o colar na borda */
box-shadow: none;          /* Remove sombras padr√µes se houver */
}
```

```{css, echo=FALSE}
h1, h2, h3, h4 {
  border-bottom: 1px solid #dddddd; /* Cria a linha cinza fina embaixo */
  padding-bottom: 12px;              /* Espa√ßo entre o texto e a linha */
  margin-bottom: 18px;              /* Espa√ßo depois da linha para o pr√≥ximo par√°grafo */
  margin-top: 28px;                 /* Espa√ßo antes do t√≠tulo */
```

```{r setup, include=FALSE}
library(tidyverse)
library(patchwork)
library(gridExtra)
library(cowplot)
library(grid)
library(MASS)      # Para gerar dados correlacionados (mvrnorm)

# Ativar o bot√£o de copiar
xaringanExtra::use_clipboard(
  button_text = "Copiar",
  success_text = "Copiado!",
  error_text = "Pressione Ctrl+C para copiar"
)
```



# 1. Introdu√ß√£o

### 1.1. O que √© tamanho de efeito?

O tamanho de efeito √© uma m√©trica utilizada para quantificar a rela√ß√£o entre duas entidades, capturando tanto a dire√ß√£o quanto a magnitude desse fen√¥meno. Diferente de um simples teste de hip√≥tese (que diz se algo funcionou ou n√£o), o tamanho de efeito nos diz o quanto funcionou. Essencialmente, √© a moeda comum que permite comparar e combinar resultados de estudos diferentes em uma metan√°lise.

- **M√©dia Amostral**
  - Ex: "Qual √© a altura m√©dia de crian√ßas de 10 anos nesta popula√ß√£o espec√≠fica?"
  
- **Propor√ß√µes**
  - Ex: "Qual √© a preval√™ncia de burnout em profissionais de enfermagem que trabalham em UTI?"

- **Coeficiente de Correla√ß√£o** (ex: r de Pearson)
  - Ex: "Existe uma associa√ß√£o entre o n√≠vel de escolaridade dos pais e o sucesso acad√™mico dos filhos?" ‚Üí Ou seja, avaliar a rela√ß√£o de duas vari√°veis cont√≠nuas.

- **Diferen√ßa de M√©dias** (ex: Cohen's d, Hedges' g)
  - Ex: "O novo medicamento causa uma redu√ß√£o maior na press√£o arterial comparado ao grupo controle?" ‚Üí Ou seja, comparar grupos (Interven√ß√£o vs. Controle) usando uma vari√°vel.

- **Raz√£o de Chances ou Risco** (Odds Ratio / Risk Ratio)
  - Ex: "Fumantes t√™m maior probabilidade de desenvolver c√¢ncer de pulm√£o do que n√£o fumantes?" ‚Üí Ou seja, avaliar desfechos bin√°rios (Sim/N√£o, Doente/Saud√°vel, Vivo/Morto).


### 1.2. Entendendo Amostragem

#### a) Popula√ß√£o vs. Amostragem

Imagine que quis√©ssemos saber o n√≠vel m√©dio exato de Hemoglobina Glicada (HbA1c) de todos os pacientes diab√©ticos do mundo sob tratamento com um novo f√°rmaco.

Se tiv√©ssemos recursos infinitos, medir√≠amos a HbA1c de cada um desses milh√µes de pacientes. Ao final, ter√≠amos uma distribui√ß√£o com uma m√©dia exata (ex: 7,5%) e um desvio padr√£o exato. Na estat√≠stica, chamamos esses valores de Par√¢metros Populacionais. Eles representam a verdade biol√≥gica absoluta sobre aquele tratamento.

o mundo real, nunca temos tempo, dinheiro ou capacidade log√≠stica para medir a popula√ß√£o inteira. √â aqui que entra a ci√™ncia pr√°tica: n√≥s fazemos uma **Amostragem**.

Quando um pesquisador publica um Ensaio Cl√≠nico Randomizado (RCT) com 100 pacientes para testar esse f√°rmaco, ele est√° pegando apenas uma pequena fatia da popula√ß√£o global. Com base nos dados desses 100 pacientes, ele calcula uma m√©dia e um desvio padr√£o. Mas aten√ß√£o: estes n√£o s√£o os Par√¢metros Populacionais. Eles s√£o apenas Estimativas.

<br>

> **A Realidade Estat√≠stica**: √â extremamente improv√°vel que a m√©dia de HbA1c encontrada nesse estudo seja exatamente igual √† m√©dia real da popula√ß√£o mundial (7,5%). Sempre haver√° um erro aleat√≥rio.

<br>

#### b) Teorema do Limite Central: E se repet√≠ssemos a amostragem? 

O que aconteceria se, em vez de fazer apenas um estudo medindo a HbA1c de 100 pacientes, n√≥s repet√≠ssemos esse mesmo estudo 1.000 vezes? Ter√≠amos 1.000 m√©dias diferentes (7,2%, 7,1%, 7,5%, 7,3%...). Se colocarmos todas essas m√©dias em um gr√°fico (histograma), observaremos um fen√¥meno fascinante:

1. A maioria das m√©dias dos estudos vai se acumular em torno de um valor central.

2. Algumas poucas m√©dias (os estudos "azarados" ou extremos) ficar√£o mais afastadas.

```{r, echo = F, fig.cap="Aqui est√° representada uma distribui√ß√£o verdadeira do n√≠vel de HbA1C em % de uma popula√ß√£o. Foram feitos 10 estudos com 3 participantes que tentaram estimar a m√©dia da hemoglobina glicada da popula√ß√£o. Perceba que esses estudos n√£o conseguem estimar perfeitamente a m√©dia populacional. Existe uma diferen√ßa que √© chamada de erro amostral."}
set.seed(123)

# --- 1. Defini√ß√£o do Cen√°rio ---
mu_real <- 7.0      
sigma_real <- 1.0   
n_estudos <- 10     
n_pacientes <- 3    # N baixo para mostrar o caos

# --- 2. Gerar Dados ---
dados_amostras <- data.frame(
  estudo_id = rep(1:n_estudos, each = n_pacientes),
  hba1c = rnorm(n_estudos * n_pacientes, mean = mu_real, sd = sigma_real)
)

dados_resumo <- dados_amostras %>%
  group_by(estudo_id) %>%
  summarise(media_amostral = mean(hba1c))

# --- 3. Gr√°fico Superior (Popula√ß√£o) ---
x_range <- seq(mu_real - 4*sigma_real, mu_real + 4*sigma_real, length.out = 1000)
dados_populacao <- data.frame(
  x = x_range,
  y = dnorm(x_range, mean = mu_real, sd = sigma_real)
)
limites_x <- c(4, 10) 

plot_top <- ggplot(dados_populacao, aes(x = x, y = y)) +
  geom_area(fill = "grey90", color = "black", size = 0.8) +
  geom_vline(xintercept = mu_real, linetype = "dashed", size = 1, color = "#E74C3C") +
  labs(title = "Popula√ß√£o (Par√¢metro)", y = "", x = NULL) +
  scale_x_continuous(limits = limites_x) +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 16))

# --- 4. Gr√°fico Inferior (Amostras) ---
plot_bottom <- ggplot() +
  # A. Linha Vertical da Verdade
  geom_vline(xintercept = mu_real, linetype = "dashed", size = 0.8, color = "#E74C3C", alpha = 0.5) +
  
  # B. Linhas de ERRO (Setas)
  # Nota: Aqui usamos 'estudo_id' num√©rico direto no Y
  geom_segment(data = dados_resumo, 
               aes(x = media_amostral, xend = mu_real, 
                   y = estudo_id, yend = estudo_id),
               color = "red", linetype = "solid", size = 0.8, 
               arrow = arrow(length = unit(0.2, "cm"))) +
  
  # C. Pontos Brutos (Pacientes)
  geom_point(data = dados_amostras, 
             aes(x = hba1c, y = estudo_id), 
             color = "grey60", alpha = 0.8, size = 2) +
  
  # D. M√©dia da Amostra (Losango Azul)
  geom_point(data = dados_resumo, 
             aes(x = media_amostral, y = estudo_id), 
             shape = 18, size = 5, color = "blue") +
  
  # Est√©tica
  labs(x = "N√≠vel de HbA1c", y = "Estudo N¬∫") +
  
  # AQUI ESTAVA O PROBLEMA: Agora definimos explicitamente como cont√≠nuo, 
  # mas for√ßamos 'breaks' inteiros para parecerem linhas.
  scale_x_continuous(limits = limites_x) +
  scale_y_continuous(breaks = 1:n_estudos) + 
  
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major.y = element_line(color = "grey95"),
    panel.grid.minor = element_blank()
  )

# --- 5. Combinar ---
final_plot <- plot_top / plot_bottom + plot_layout(heights = c(1, 4))

print(final_plot)
```

Essa cole√ß√£o de m√©dias de v√°rios estudos hipot√©ticos cria o que chamamos de Distribui√ß√£o Amostral. Aqui entra uma das regras mais importantes da estat√≠stica para a metan√°lise. Voc√™ pode se perguntar: "E se os dados originais dos pacientes n√£o forem normais?" (Ex: tempo de interna√ß√£o hospitalar, que geralmente n√£o segue uma curva normal).

O **Teorema do Limite Central** afirma que, independentemente da distribui√ß√£o dos dados originais (seja uniforme, exponencial, etc.), se pegarmos as m√©dias dessas amostragens, a distribui√ß√£o dessas m√©dias ser√° sempre Normal (uma curva de sino).

```{r, echo = F, fig.cap="Foram retiradas amostras pequenas (n = 5), m√©dias (n = 30) e grandes (n = 100) de uma distribui√ß√£o populacional exponencial e calculadas a m√©dia de cada amostra. Perceba que a distribui√ß√£o amostral das m√©dias (mesmo que a distribui√ß√£o amostral original n√£o seja normal) vai aproximando-se de uma distribui√ß√£o normal. Perceba tamb√©m que quanto maior a amostra menor o desvio padr√£o dessa distribui√ß√£o amostral (vamos chamar depois isso de menor erro amostral :D)"}
set.seed(42)

# --- 1. CORES E EST√âTICA ---
cor_pop_fill   <- "#FAE5D3"  
cor_pop_line   <- "#D35400"  
cor_samp_fill  <- "#D1F2EB"  
cor_samp_line  <- "#117864"  
cor_seta       <- "#F1C40F"  
cor_seta_baixo <- "#5DADE2"  

# Tema base limpo
theme_clean <- theme_classic() +
  theme(
    axis.line = element_line(color = "grey85"),
    axis.ticks = element_line(color = "grey85"),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 12),
    axis.title = element_text(size = 10),
    plot.background = element_rect(fill = "white", color = NA),
    plot.margin = margin(t = 10, r = 10, b = 10, l = 10) 
  )

# --- 2. DADOS ---
populacao <- rexp(50000, rate = 0.8) 
df_pop <- data.frame(x = populacao)

# --- 3. GR√ÅFICO SUPERIOR ---
plot_pop <- ggplot(df_pop, aes(x = x)) +
  geom_histogram(bins = 40, fill = cor_pop_fill, color = cor_pop_line, size = 0.2) +
  labs(title = "Population", y = "Frequency", x = "") +
  scale_x_continuous(breaks = 0:8, limits = c(0, 8), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) + 
  theme_clean

# --- 4. FUN√á√ÉO PARA OS GR√ÅFICOS DE BAIXO ---
criar_plot_amostra <- function(n, show_y_label = FALSE) {
  medias <- replicate(2000, mean(sample(populacao, n)))
  df_medias <- data.frame(m = medias)
  
  p <- ggplot(df_medias, aes(x = m)) +
    geom_histogram(bins = 30, fill = cor_samp_fill, color = cor_samp_line, size = 0.2) +
    # Mantendo X e Y com "ch√£o" no zero
    scale_x_continuous(limits = c(0, 4), breaks = c(0, 1, 2, 3, 4)) + 
    scale_y_continuous(expand = c(0, 0)) +
    theme_clean +
    theme(
      axis.text.x = element_text(size = 9, color = "grey30"), 
      # AQUI EST√Å A MUDAN√áA: Garante que o texto do eixo Y sempre apare√ßa
      axis.text.y = element_text(size = 8, color = "grey40"), 
      plot.margin = margin(t = 5, r = 8, b = 15, l = 5) # Ajuste leve na margem direita para os n√∫meros n√£o cortarem
    )
  
  # Condicional apenas para o T√çTULO do eixo ("Frequency"), n√£o para os n√∫meros
  if(show_y_label) {
    p <- p + labs(y = "Frequency", x = "")
  } else {
    p <- p + labs(y = "", x = "") 
  }
  return(p)
}

# Gerar os gr√°ficos (Todos agora ter√£o n√∫meros no eixo Y)
p5   <- criar_plot_amostra(5, show_y_label = TRUE)  # Este tem o t√≠tulo "Frequency"
p30  <- criar_plot_amostra(30, show_y_label = FALSE) # Este tem apenas n√∫meros
p100 <- criar_plot_amostra(100, show_y_label = FALSE) # Este tem apenas n√∫meros

# --- 5. MONTAGEM DO LAYOUT ---
# Usamos align = "h" e axis = "tb" para garantir que os eixos fiquem alinhados 
# mesmo com larguras de n√∫meros diferentes (ex: 500 vs 1000)
row_bottom <- plot_grid(
  p5, p30, p100, 
  nrow = 1, 
  align = "h", axis = "tb",
  labels = c("n=5", "n=30", "n=100"), 
  label_size = 11, 
  label_y = 0.02,   
  label_x = 0.5,    
  hjust = 0.5,
  vjust = 0         
)

grid_plots <- plot_grid(
  plot_pop, 
  row_bottom, 
  ncol = 1, 
  rel_heights = c(1, 1.3), 
  scale = 0.95             
)

# --- 6. SETAS E DETALHES FINAIS ---
final_plot <- ggdraw(grid_plots) +
  # Setas Superiores
  draw_line(x = c(0.40, 0.20), y = c(0.53, 0.42), color = cor_seta, size = 1.2, arrow = arrow(length = unit(0.25, "cm"), type = "closed")) +
  draw_line(x = c(0.5, 0.5), y = c(0.53, 0.42), color = cor_seta, size = 1.2, arrow = arrow(length = unit(0.25, "cm"), type = "closed")) +
  draw_line(x = c(0.60, 0.80), y = c(0.53, 0.42), color = cor_seta, size = 1.2, arrow = arrow(length = unit(0.25, "cm"), type = "closed")) +
  
  # Seta Inferior
  draw_line(x = c(0.05, 0.95), y = c(0.01, 0.01), color = cor_seta_baixo, size = 2, arrow = arrow(length = unit(0.4, "cm"), type = "closed"))

print(final_plot)
```

<br>

> **Por que isso importa na medicina?** N√£o precisamos nos preocupar tanto se a vari√°vel biol√≥gica original (como carga viral ) tem uma distribui√ß√£o estranha. Desde que tenhamos um n√∫mero amostral suficiente (geralmente acima de 30), podemos assumir que as m√©dias dos estudos que vamos combinar na metan√°lise se comportam como uma curva Normal.

<br>

#### c) Erro Padr√£o: Qu√£o precisa √© a m√©dia das amostragens?

Agora que sabemos que as m√©dias de v√°rios estudos formam uma curva, precisamos medir a "largura" dessa curva. √â aqui que muita gente confunde Desvio Padr√£o com Erro Padr√£o. Vamos diferenciar:

- **Desvio Padr√£o (SD)**: Mede o quanto UMA amostragem est√° espalhada. √â a varia√ß√£o biol√≥gica entre paciente e paciente (ex: o quanto a glicemia varia entre os sujeitos do estudo).

- **Erro Padr√£o (SE)**: Mede o quanto a m√©dia de v√°rias amostragens est√° espalhada. Ele √©, basicamente, o desvio padr√£o das m√©dias de v√°rios estudos.

```{r, echo=F, fig.cap="Simula√ß√£o feita com 5.000 estudos com tamanho amostral pequeno (n = 30) com m√©dia verdadeira de HbA1c de 7% e desvio padr√£o de 1%. Perceba que esses 5.000 estudos tem uma distribui√ß√£o amostral de m√©dia seguindo uma distribui√ß√£o normal. O desvio padr√£o dessa distribui√ß√£o amostral chama-se erro padr√ßao."}
set.seed(42)

# --- 1. Par√¢metros do Diabetes (HbA1c) ---
mu_hba1c <- 7.0      # M√©dia Real
sigma_hba1c <- 1.0   # Desvio Padr√£o Real
n_amostra <- 30      # Tamanho de cada estudo

# C√°lculo do Erro Padr√£o Te√≥rico (Para desenhar a linha exata)
se_teorico <- sigma_hba1c / sqrt(n_amostra) # ~0.18

# --- 2. Simula√ß√£o ---
# 5000 estudos simulados
medias_simuladas <- replicate(5000, mean(rnorm(n_amostra, mean = mu_hba1c, sd = sigma_hba1c)))
df_sim <- data.frame(m = medias_simuladas)

# --- 3. C√°lculos de Posi√ß√£o para o Gr√°fico ---
# Descobrir a altura m√°xima da curva normal para posicionar a linha ACIMA dela
altura_max <- dnorm(mu_hba1c, mean = mu_hba1c, sd = se_teorico)
posicao_linha_y <- altura_max * 1.05  # 5% acima do pico
posicao_texto_y <- altura_max * 1.12  # Um pouco acima da linha

# --- 4. O Gr√°fico ---
ggplot(df_sim, aes(x = m)) +
  # A. Histograma (Dados Simulados)
  geom_histogram(aes(y = ..density..), bins = 50, 
                 fill = "#D1F2EB", color = "white", alpha = 0.8) +
  
  # B. Curva Normal Te√≥rica (O "Sino")
  stat_function(fun = dnorm, args = list(mean = mu_hba1c, sd = se_teorico),
                color = "#117864", size = 1.2) +
  
  # C. Linha Central (M√©dia) - Tracejada at√© o topo
  geom_segment(aes(x = mu_hba1c, xend = mu_hba1c, y = 0, yend = posicao_linha_y), 
               linetype = "dashed", color = "grey60", size = 0.8) +
  
  # D. A Linha Horizontal do Erro Padr√£o (Sim√©trica: Esquerda e Direita)
  # Vai de (M√©dia - SE) at√© (M√©dia + SE)
  geom_segment(aes(x = mu_hba1c - se_teorico, xend = mu_hba1c + se_teorico, 
                   y = posicao_linha_y, yend = posicao_linha_y),
               color = "#E74C3C", size = 1.2) +
  
  # E. Pontas da linha (para parecer uma r√©gua de medida |---|)
  geom_segment(aes(x = mu_hba1c - se_teorico, xend = mu_hba1c - se_teorico,
                   y = posicao_linha_y - 0.05, yend = posicao_linha_y + 0.05),
               color = "#E74C3C", size = 1.2) +
  geom_segment(aes(x = mu_hba1c + se_teorico, xend = mu_hba1c + se_teorico,
                   y = posicao_linha_y - 0.05, yend = posicao_linha_y + 0.05),
               color = "#E74C3C", size = 1.2) +

  # F. R√≥tulo
  annotate("text", x = mu_hba1c, y = posicao_texto_y, 
           label = "Erro Padr√£o (SE)", color = "#E74C3C", fontface = "bold", size = 5) +
  
  # Est√©tica Limpa
  labs(x = "M√©dia de HbA1c (%)", y = "Densidade") +
  scale_x_continuous(breaks = seq(6, 8, 0.2)) + # Escala focada nos valores de HbA1c
  scale_y_continuous(expand = expansion(mult = c(0, 0.2))) + # Mais espa√ßo no topo para o texto
  theme_classic(base_size = 14) +
  theme(
    axis.line.y = element_blank(), # Remove eixo Y para ficar mais limpo
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank()
  )
```

<br>

**Como interpretar?**: O Erro Padr√£o √© uma medi√ß√£o do qu√£o representativas s√£o nossas amostragens em rela√ß√£o √† popula√ß√£o.

- **Alto Erro Padr√£o**: As m√©dias dos estudos variam muito entre si. O estudo √© pouco preciso.

- **Baixo Erro Padr√£o**: As m√©dias variam pouco. O estudo √© uma boa representa√ß√£o da popula√ß√£o.

```{r, echo=F, fig.cap="Foi feita uma simula√ß√£o com desvio padr√£o fixo de 15 e valores crescentes de tamanho amostral (5, 10, 15...). Perceba que o erro padr√£o decresce aproximadamente exponencialmente com o tamanho amostral. "}
# Simular o comportamento do Erro Padr√£o
n_vals <- seq(5, 200, by = 5)
sd_fixo <- 15 # Vamos supor um desvio padr√£o fixo de 15 unidades (ex: press√£o arterial)

df_erro <- data.frame(
  n = n_vals,
  se = sd_fixo / sqrt(n_vals) # A f√≥rmula m√°gica
)

g3 <- ggplot(df_erro, aes(x = n, y = se)) +
  # Linha da tend√™ncia
  geom_line(color = "#E74C3C", size = 1.5) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 10)) +
  # Pontos para marcar os steps
  geom_point(size = 3, color = "#C0392B") +
  # √Årea sombreada para dar ideia de redu√ß√£o da incerteza
  geom_area(fill = "#E74C3C", alpha = 0.2) +
  labs(
    x = "Tamanho da Amostra (n)",
    y = "Erro Padr√£o (SE)"
  ) +
  theme_classic(base_size = 14) +
  scale_x_continuous(expand = c(0, 0), limits = c(5, NA), breaks = seq(0, 200, 50))

print(g3)
```

*Nota: O Erro Padr√£o ser√° sempre menor que o Desvio Padr√£o, pois as m√©dias s√£o naturalmente menos dispersas do que as observa√ß√µes individuais.*

```{r, echo=F, fig.cap="Em cinza temos a distribui√ß√£o populacional do n√≠vel de HbA1c (%), perceba que ela √© mais espalhada. Ao fazer estudos para retirar a m√©dia desse valor, temos uma quantidade menos espalhada de m√©dias. O desvio padr√£o dessa distribui√ß√£o amostral √© chamado de erro padr√£o."}
library(ggplot2)
library(dplyr)
library(patchwork)

set.seed(123)

# 1. Simular uma Popula√ß√£o "Real" (ex: 100.000 pacientes)
# Usaremos uma distribui√ß√£o Gamma para dar uma leve assimetria (comum em biologia)
# M√©dia aprox 7.0, mas com cauda longa
populacao <- rgamma(100000, shape = 15, scale = 0.5) 
media_real <- mean(populacao)
sd_pop <- sd(populacao)

# 2. Simular a "Amostragem Repetida" (O exerc√≠cio mental da Metan√°lise)
# Vamos pegar 1.000 amostras de 30 pacientes cada e tirar a m√©dia
n_amostra <- 30
n_simulacoes <- 1000

medias_amostrais <- replicate(n_simulacoes, {
  amostra <- sample(populacao, n_amostra)
  mean(amostra)
})

# Preparar dados para plotar
df_pop <- data.frame(valor = populacao, tipo = "Popula√ß√£o (Pacientes Individuais)")
df_medias <- data.frame(valor = medias_amostrais, tipo = "Distribui√ß√£o das M√©dias (Estudos)")

# GR√ÅFICO 1: A Compara√ß√£o
g1 <- ggplot() +
  # Curva da Popula√ß√£o (Fundo, cinza)
  geom_density(data = df_pop, aes(x = valor, fill = "Popula√ß√£o"), 
               alpha = 0.4, color = "grey40") +
  # Curva das M√©dias (Frente, destaque)
  geom_density(data = df_medias, aes(x = valor, fill = "M√©dias dos Estudos"), 
               alpha = 0.7, color = "darkblue") +
  # Linha da M√©dia Real
  geom_vline(xintercept = media_real, linetype = "dashed", size = 1) +
  # Decora√ß√£o
  scale_fill_manual(values = c("Popula√ß√£o" = "#999999", "M√©dias dos Estudos" = "#2E86C1"), name = "") +
  labs(
    x = "N√≠vel de HbA1c (%)",
    y = "Densidade"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom") +
  annotate("text", x = 10, y = 0.2, label = "Desvio Padr√£o (SD)\n√© a largura desta curva", color = "grey30", hjust=0) +
  annotate("text", x = 8.5, y = 1, label = "Erro Padr√£o (SE)\n√© a largura desta curva", color = "#2E86C1", hjust=0, fontface="bold")

print(g1)
```


<br>

#### d) Erro Padr√£o: E se eu tiver apenas um estudo?

Voc√™ deve estar pensando: "Mas eu s√≥ tenho UM estudo em m√£os, eu n√£o repeti a amostragem 1.000 vezes. Como eu descubro o Erro Padr√£o?"

A estat√≠stica nos d√° um atalho. √â poss√≠vel estimar o erro padr√£o tendo apenas uma amostragem (o estudo que voc√™ est√° lendo). Existe uma "F√≥rmula Especial" para o Erro Padr√£o da M√©dia:

$$SE = \frac{s}{\sqrt{n}}$$

Onde:

- $\sigma$ = Desvio Padr√£o (do estudo).

- $n$ = Tamanho da amostra (n√∫mero de pacientes).

> **Interpreta√ß√£o para Metan√°lise**: Olhe para a f√≥rmula. O $n$ est√° no denominador. Isso prova matematicamente que quanto maior o n√∫mero de pacientes ($n$), menor ser√° o erro padr√£o ($SE$).Na metan√°lise, estudos com $SE$ menor (mais precisos) ganhar√£o mais peso na decis√£o final.

<br>


## 2. M√©tricas Comuns

### 2.1. M√©dia Aritm√©trica

A m√©dia aritm√©tica √© uma das medidas de tend√™ncia central poss√≠veis de serem utilizadas em metan√°lises. Ela deve ser necessariamente utilizada quando todos os estudos utilizam a mesma m√©trica e n√£o h√° um grupo controle. Por exemplo, para investigar a altura m√©dia de uma popula√ß√£o. 

Ela √© calculada da seguinte forma:

$$ \bar{x} = \frac{\sum_{i=1}^{n} x_i}{n} $$

```{r media}
# Definir semente para reprodutibilidade
set.seed(100)

# Gerar uma amostra aleat√≥ria (n=50) com m√©dia 20 e desvio padr√£o 5
sample <- rnorm(n = 50, mean = 20, sd = 5)

# Calcular a m√©dia
media_calculada <- mean(sample)
print(paste("M√©dia:", media_calculada))
```

<br>

N√≥s j√° falamos sobre como calcular o erro padr√£o da m√©dia. Mas aqui est√° relembrando para voc√™!

$$ SE_{\bar{x}} = \frac{s}{\sqrt{n}} $$

```{r se_media}
# Calcular o Erro Padr√£o (SD dividido pela raiz quadrada de n)
erro_padrao <- sd(sample) / sqrt(50)
print(paste("Erro Padr√£o:", erro_padrao))
```

<br>

Para conduzir uma metan√°lise de m√©dias, seu banco de dados precisa obrigatoriamente conter tr√™s informa√ß√µes (colunas) de cada estudo inclu√≠do:

- $n$: O tamanho da amostra (n√∫mero de observa√ß√µes).
- $mean$: A m√©dia relatada no estudo.
- $sd$: O desvio padr√£o da vari√°vel.

### 2.2. Propor√ß√µes

#### a) O que √©?

A propor√ß√£o √© uma medida de tend√™ncia central que especifica quantas unidades de uma amostra pertencem a um subgrupo espec√≠fico (ex: preval√™ncia de uma doen√ßa). Novamente, trata-se de uma medida em que n√£o h√° compara√ß√£o de grupos. Ela varia entre 0 e 1 e √© calculada dividindo o n√∫mero de eventos ($k$) pelo tamanho total da amostra ($n$).

A propor√ß√£o √© calculada como:

$$ p = \frac{k}{n} $$

```{r prop}
# Definir valores: k (eventos) e n (total)
k <- 50
n <- 200

# C√°lculo da Propor√ß√£o Bruta 
p <- k / n
print(paste("Propor√ß√£o (p):", p))

```

<br>

O erro padr√£o da propor√ß√£o √© calculado como: 

$$ SE_p = \sqrt{\frac{p(1-p)}{n}} $$
```{r prop_se}
# Erro Padr√£o da Propor√ß√£o
se_p <- sqrt((p * (1 - p)) / n)
print(paste("Erro Padr√£o (Raw):", se_p))
```


#### b) O problema dos extremos

Como a propor√ß√£o √© limitada entre 0 e 1, surgem problemas quando o valor de $p$ √© muito pr√≥ximo de 0 ou de 1.

- **Erro Padr√£o Comprimido**: O erro padr√£o √© artificialmente reduzido, levando a uma superestima√ß√£o da precis√£o.
- **Distribui√ß√£o Assim√©trica**: A distribui√ß√£o amostral deixa de ser normal (Sino) e torna-se enviesada (*skewed*) √† esquerda ou direita, pois √© imposs√≠vel ter valores fora do intervalo 0-1.

<br>

```{r, echo=F, message=FALSE, warning=F, fig.width=10, fig.cap="A. Simula√ß√£o de distribui√ß√£o amostral de 10.000 estudos de grande tamanho (n = 300) em que a propor√ß√£o populacional (verdadeira) √© alta (0.95). Isso faz com que a distribui√ß√£o de propor√ß√£o bruta seja espremida e assim√©trica para a direita. B. O erro padr√£o associado a essa distribui√ß√£o √© m√°ximo  no centro e menor nas pontas, o que n√£o √© intuitivo pois nas pontas temos menor certeza."}
# --- CONFIGURA√á√ÉO EST√âTICA ---
cor_raw   <- "#E67E22" # Laranja (Propor√ß√£o Bruta)
cor_logit <- "#2980B9" # Azul (Logit)
theme_set(theme_minimal(base_size = 12))

# ==============================================================================
# PARTE 1: SIMULA√á√ÉO DA DISTRIBUI√á√ÉO (SKEWNESS / ASSIMETRIA)
# ==============================================================================

set.seed(42)
n_sim <- 10000    # N√∫mero de estudos simulados
n_sample <- 300   # Tamanho da amostra pequeno/m√©dio
p_real <- 0.95   # Propor√ß√£o EXTREMA (perto de 1.0)

# 1. Gerar os dados
# rbinom gera o n√∫mero de sucessos (k)
sim_k <- rbinom(n_sim, size = n_sample, prob = p_real)
sim_p <- sim_k / n_sample

# 2. Filtrar 0 e 1 puros para o Logit n√£o dar Infinito (limita√ß√£o matem√°tica)
validos <- sim_p > 0 & sim_p < 1
sim_p_clean <- sim_p[validos]

# 3. Transformar para Logit
sim_logit <- log(sim_p_clean / (1 - sim_p_clean))

# DF para plotagem
df_dist <- data.frame(
  type = c(rep("Propor√ß√£o Bruta (p)", length(sim_p_clean)), 
           rep("Transforma√ß√£o Logit", length(sim_logit))),
  value = c(sim_p_clean, sim_logit)
)

# --- Gr√°fico 1.A: A Assimetria (Skewed) ---
p1a <- ggplot(data.frame(x = sim_p_clean), aes(x = x)) +
  geom_histogram(aes(y = ..density..), bins = 100, fill = cor_raw, color = "white", alpha=0.8) +
  geom_density(color = "#D35400", size = 1) +
  geom_vline(xintercept = 1.0, linetype = "dashed", color = "black") +
  scale_x_continuous(limits = c(0.5,1)) + 
  labs(title = "A. Propor√ß√£o Bruta (p)", x = "Propor√ß√£o Estimada", y = "Densidade")

# --- Gr√°fico 1.B: A Normaliza√ß√£o (Logit) ---
p1b <- ggplot(data.frame(x = sim_logit), aes(x = x)) +
  geom_histogram(aes(y = ..density..), bins = 20, fill = cor_logit, color = "white", alpha=0.8) +
  geom_density(color = "#1F618D", size = 1) +
  labs(title = "A. Ap√≥s Transforma√ß√£o Logit", 
       x = "Logit Value", y = "Densidade")

# ==============================================================================
# PARTE 2: A COMPRESS√ÉO DO ERRO PADR√ÉO (PRECIS√ÉO ARTIFICIAL)
# ==============================================================================

# Vamos criar uma sequ√™ncia de p de 0.01 at√© 0.99
seq_p <- seq(0.01, 0.99, length.out = 200)
n_fixo <- 100

# F√≥rmulas de Erro Padr√£o
se_raw <- sqrt((seq_p * (1 - seq_p)) / n_fixo)
se_logit <- sqrt(1/(n_fixo * seq_p) + 1/(n_fixo * (1 - seq_p)))

df_se <- data.frame(
  p = seq_p,
  se_raw = se_raw,
  se_logit = se_logit
)

# --- Gr√°fico 2.A: O Problema (Compress√£o) ---
p2a <- ggplot(df_se, aes(x = p, y = se_raw)) +
  geom_line(color = cor_raw, size = 1.5) +
  geom_area(fill = cor_raw, alpha = 0.2) +
  annotate("text", x = 0.5, y = 0.04, label = "M√°ximo Erro\n(p=0.5)", color = "grey30") +
  annotate("text", x = 0.9, y = 0.02, label = "Erro 'Falso'\nBaixo", fontface="bold", color = "#D35400") +
  labs(title = "B. Erro Padr√£o da Propor√ß√£o (SE p)", 
       x = "Valor de p", y = "Tamanho do Erro (SE)") +
  scale_y_continuous(limits = c(0, 0.06))

# --- Gr√°fico 2.B: A Solu√ß√£o (Expans√£o) ---
p2b <- ggplot(df_se, aes(x = p, y = se_logit)) +
  geom_line(color = cor_logit, size = 1.5) +
  geom_area(fill = cor_logit, alpha = 0.2) +
  annotate("text", x = 0.9, y = 0.5, label = "Erro Real\nAlto", fontface="bold", color = "#1F618D") +
  labs(title = "B. Erro Padr√£o do Logit (SE logit)",
       x = "Valor de p", y = "Tamanho do Erro (SE)")

p1a + p2a
```


#### c) A solu√ß√£o üòÅ

Para corrigir isso em metan√°lises, utilizamos a transforma√ß√£o em log natural - chamada de **logit**. Ela remove a restri√ß√£o de intervalo 0-1, garantindo que a distribui√ß√£o amostral seja aproximadamente normal e os erros padr√£o n√£o sejam enviesados.

A transforma√ß√£o da propor√ß√£o para logit da propor√ß√£o:

$$ p_{\text{logit}} = \log_e \left( \frac{p}{1-p} \right) $$


```{r}
# O logit transforma o intervalo 0-1 em -inf a +inf
p_logit <- log(p / (1 - p))
print(paste("Propor√ß√£o Transformada (Logit):", p_logit))
```

<br>

O erro padr√£o do logit da propor√ß√£o:

$$ SE_{p_{\text{logit}}} = \sqrt{\frac{1}{np} + \frac{1}{n(1-p)}} $$

```{r logit_prop}
se_logit <- sqrt((1 / (n * p)) + (1 / (n * (1 - p))))
print(paste("Erro Padr√£o (Logit):", se_logit))
```

<br>

```{r, echo=F, fig.width=10, fig.cap="A. Simula√ß√£o de distribui√ß√£o amostral de 10.000 estudos de grande tamanho (n = 300) em que a propor√ß√£o populacional (verdadeira) √© alta (0.95) ap√≥s a transforma√ß√£o logit. Isso faz com que a distribui√ß√£o assuma um formato aproximadamente normal em que os limites transformam-se em menos e mais infinito. B. O erro padr√£o associado a essa distribui√ß√£o √© m√°ximo nas pontas e menor no centro, o que√© intuitivo pois no centro temos maior certeza."}
p1b + p2b
```

<br>

Para conduzir uma metan√°lise de m√©dias, seu banco de dados precisa obrigatoriamente conter duas informa√ß√µes (colunas) de cada estudo inclu√≠do:

- $event$: O n√∫mero de observa√ß√µes no subgrupo espec√≠fico ($k$).
- $n$: O tamanho total da amostra.

## Correla√ß√£o

### a) O que √©?

A correla√ß√£o √© uma medida de tamanho de efeito que expressa a for√ßa da rela√ß√£o ("co-varia√ß√£o") entre duas vari√°veis cont√≠nuas.Exemplo Pr√°tico: Imagine que queremos investigar a rela√ß√£o entre Idade (anos) e Press√£o Arterial Sist√≥lica (mmHg). Se a correla√ß√£o for positiva e forte, significa que conforme a idade aumenta, a press√£o tamb√©m tende a subir.

A forma mais comum √© a Correla√ß√£o de Pearson ($r$). Uma de suas maiores vantagens √© que ela padroniza os dados. Isso significa que n√£o importa a unidade de medida usada no estudo original.Estudo Exemplo, o estudo A mediu altura em cent√≠metros. Estudo B mediu altura em polegadas.Uma correla√ß√£o de $r=0.50$ no Estudo A √© matematicamente id√™ntica a $r=0.50$ no Estudo B, permitindo que comparemos os efeitos diretamente.

A correla√ß√£o de Pearson √© calculada da seguinte forma:


$$ r_{xy} = \frac{\sigma^2_{xy}}{\sigma_x \sigma_y} $$

<br>

E esse resultado pode ser obtido atrav√©s da fun√ß√£o `cor`: 

```{r}
x <- c(10, 12, 15, 20, 25)
y <- c(6, 16, 18, 21, 35)

# Calculate the correlation between x and y
r <- cor(x,y)
r
```

<br>

O erro padr√£o associado √© calculado atrav√©s da f√≥rmula:

$$ SE_{r_{xy}} = \frac{1 - r^2_{xy}}{\sqrt{n - 2}} $$

### b) Interpretando magnitude

Cohen prop√¥s regras de bolso para classificar a for√ßa dessa rela√ß√£o, mas lembre-se que o contexto cl√≠nico importa muito.

- **$r \approx 0.10$** (Efeito Pequeno): A rela√ß√£o existe, mas √© sutil e influenciada por muitos outros fatores.

- **$r \approx 0.30$** (Efeito Moderado): A rela√ß√£o √© vis√≠vel a olho nu nos dados.

- **$r \approx 0.50$** (Efeito Grande): Uma vari√°vel prediz a outra fortemente.

### c) O Problema Estat√≠stico e a Solu√ß√£o (Fisher's z)

Assim como acontece com propor√ß√µes, correla√ß√µes s√£o "presas" dentro de um intervalo (de -1 a +1).Se um estudo encontra uma correla√ß√£o muito alta (ex: $r = 0.95$ entre dois testes diagn√≥sticos), a distribui√ß√£o amostral fica espremida no teto do 1.0, gerando erros padr√µes incorretos e enviesados.Para corrigir isso na metan√°lise, usamos a Transforma√ß√£o Fisher's z. Ela "estica" o intervalo de -1 a 1 para infinito, tornando a distribui√ß√£o Normal e permitindo c√°lculos precisos de erro padr√£o.

Aqui est√° a transforma√ß√£o feita para moldar a distribui√ß√£o amostral em formato de distribui√ß√£o normal:

$$ z = 0.5 \log_e \left( \frac{1 + r}{1 - r} \right) $$

```{r}
# Calculate Fisher's z
z <- 0.5*log((1+r)/(1-r))
z
```

```{r, echo = F, fig.width=10, fig.cap="Por que n√£o podemos usar correla√ß√µes brutas na metan√°lise? Aqui fizemos a simula√ß√£o de 5.000 estudos pequenos (n=30) onde a correla√ß√£o populacional √© alta (0.85). Na distribui√ß√£o amostral da correla√ß√£o de Pearson vemos que ela fica assim√©trica, espremida √† direita. Quando fazemos a transforma√ß√£o de Fischer a distribui√ß√£o torna-se aproximadamente normal e sim√©trica, com intervalos indo de menos a mais infinito."}
set.seed(42)

# --- PARTE 1: Simula√ß√£o dos Dados ---
n_sim <- 5000     # N√∫mero de estudos simulados
n_sample <- 30    # Tamanho pequeno de amostra
true_rho <- 0.85  # Correla√ß√£o verdadeira ALTA (Glicemia maq A vs maq B)

# Fun√ß√£o para simular UM estudo e calcular seu r
get_simulated_r <- function() {
  # Gera dados para 30 pacientes com correla√ß√£o de 0.85
  data <- mvrnorm(n = n_sample, mu = c(0,0), 
                  Sigma = matrix(c(1, true_rho, true_rho, 1), 2))
  cor(data[,1], data[,2]) # Calcula o r de Pearson
}

# Rodar a simula√ß√£o 5000 vezes
sim_r_values <- replicate(n_sim, get_simulated_r())

# Aplicar a transforma√ß√£o de Fisher's z
sim_z_values <- 0.5 * log((1 + sim_r_values) / (1 - sim_r_values))

# Calcular o valor verdadeiro de z para refer√™ncia
true_z <- 0.5 * log((1 + true_rho) / (1 - true_rho))

# Juntar em um data frame
df_sim <- data.frame(r = sim_r_values, z = sim_z_values)


# --- PARTE 2: Gr√°ficos Did√°ticos ---

# Est√©tica
cor_raw <- "#E67E22" # Laranja para bruto
cor_trans <- "#2980B9" # Azul para transformado

# GR√ÅFICO 1: O Problema (Correla√ß√£o Bruta r)
p1 <- ggplot(df_sim, aes(x = r)) +
  # Histograma
  geom_histogram(aes(y = ..density..), bins = 35, fill = cor_raw, color = "white", alpha = 0.7) +
  # Linha de Densidade
  geom_density(color = "#D35400", size = 1) +
  # Linha da Verdade (0.85)
  geom_vline(xintercept = true_rho, linetype = "dashed", color = "black", size = 1) +
  # O "Muro" do 1.0
  geom_vline(xintercept = 1.0, color = "#C0392B", size = 1.5) +
  annotate("text", x = 0.98, y = 1, label = "Pared√£o (Max 1.0)", color = "#C0392B", angle = 90, hjust=0) +
  
  labs(x = "Correla√ß√£o de Pearson (r)", y = "Densidade") +
  theme_minimal() +
  xlim(0.4, 1.05) # Focando na √°rea de interesse

# GR√ÅFICO 2: A Solu√ß√£o (Fisher's z)
p2 <- ggplot(df_sim, aes(x = z)) +
  # Histograma
  geom_histogram(aes(y = ..density..), bins = 35, fill = cor_trans, color = "white", alpha = 0.7) +
  # Linha de Densidade
  geom_density(color = "#1F618D", size = 1) +
  # Linha da Verdade Transformada
  geom_vline(xintercept = true_z, linetype = "dashed", color = "black", size = 1) +
  
  labs(x = "Valor Transformado (z)", y = "Densidade") +
  theme_minimal() +
  xlim(0.4, 2.5) # Ajustando escala para visualizar o z

# --- Combinar ---
final_plot <- p1 + p2 +
  plot_annotation(
    theme = theme(plot.title = element_text(face = "bold", size = 16))
  )

print(final_plot)

```

Sabendo o tamanho amostral podemos calcular o erro padr√£o do Z de Fischer atrav√©s dessa f√≥rmula:

$$ SE_z = \frac{1}{\sqrt{n - 3}} $$

<br>

Para o seu banco de dados de estudos voc√™ s√≥ precisa das colunas:

- cor (o valor de r de Pearson): A convers√£o em Z de Fischer ser√° feita internamente. 
- n (tamanho da amostra)

## Diferen√ßa de M√©dias Brutas (N√£o Padronizadas)

### O que √©?

A Diferen√ßa de M√©dias (MD) bruta √© a forma mais simples e intuitiva de medir um efeito. Ela √© simplesmente a subtra√ß√£o da m√©dia do grupo interven√ß√£o pela m√©dia do grupo controle.

$$ MD_{between} = \bar{x}_1 - \bar{x}_2 $$
```{r}
# Grupo 1 (Interven√ß√£o): M√©dia 130 mmHg, SD 15
# Grupo 2 (Controle): M√©dia 140 mmHg, SD 15

n1 <- 20; m1 <- 130; s1 <- 15
n2 <- 20; m2 <- 140; s2 <- 15

MD <- m1 - m2
print(paste("Diferen√ßa M√©dia (MD):", MD, "mmHg"))
```

Quando usar? S√≥ podemos usar a MD quando todos os estudos inclu√≠dos na metan√°lise mediram o desfecho exatamente na mesma escala/unidade. Exemplo Pr√°tico (Press√£o Arterial): Imagine que voc√™ est√° estudando um novo anti-hipertensivo.

- Estudo A mediu a press√£o arterial sist√≥lica em mmHg.

- Estudo B mediu a press√£o arterial sist√≥lica em mmHg.

Como ambos falam a "mesma l√≠ngua" (mmHg), podemos calcular que o rem√©dio baixou a press√£o em m√©dia -10 mmHg. Isso √© uma diferen√ßa de m√©dia bruta. 


### Erro Padr√£o

#### a) Entendendo a Problem√°tica

N√≥s temos duas formas de calcular o erro padr√£o, a depender se considerarmos que as duas medidas pertencentes a uma mesma popula√ß√£o ou duas popula√ß√µes diferentes. No primeiro caso, consideramos que o desvio padr√£o verdadeiro de cada grupo √© igual entre si. Ou seja, est√° √© um pressuposto estat√≠stico de homocedasticidade. No segundo caso os desvio padr√µes n√£o tem o mesmo valor, ent√£o estamos falando de heterocedasticidade. 

Em cen√°rios de desbalanceamento amostral ($n_1 \neq n_2$), a abordagem agrupada falha em capturar a verdadeira incerteza da estimativa. Isso gera um erro comum em metan√°lise, j√° que o estudo com menor n√∫mero de pacientes geralmente possui a maior vari√¢ncia (grande variabilidade em amostra pequena). Isso faz com qu√™:

- **O Erro Matem√°tico:** O m√©todo agrupado (pooled) ignora a alta vari√¢ncia do grupo pequeno, "diluindo-a" com a vari√¢ncia menor do grupo grande.

- **A Consequ√™ncia:** O Erro Padr√£o calculado √© artificialmente pequeno.

- **Impacto na Meta-An√°lise:** O algoritmo de inverso da vari√¢ncia entende que este estudo √© extremamente preciso (o que √© falso) e atribui a ele um peso desproporcionalmente alto. Um estudo "ruidoso" e de baixa qualidade estat√≠stica passa a dominar a estimativa do efeito global.

#### b) Assumindo o mesmo desvio padr√£o (homocedasticidade)

Calcula-se o desvio padr√£o agrupado ($s_{pooled}$) atrav√©s da f√≥rmula

$$ s_{pooled} = \sqrt{\frac{(n_1 - 1)s^2_1 + (n_2 - 1)s^2_2}{n_1 + n_2 - 2}} $$
Ent√£o, utilizamos esse desvio padr√£o agrupado para calcular o erro padr√£o.
$$ SE_{MD_{between}} = s_{pooled} \sqrt{\frac{1}{n_1} + \frac{1}{n_2}} $$

```{r}
s_pooled <- sqrt( (((n1-1)*s1^2) + ((n2-1)*s2^2)) / (n1 + n2 - 2) )

se_md <- s_pooled * sqrt((1/n1) + (1/n2))
print(paste("Erro Padr√£o (Agrupado):", round(se_md, 3)))
```


#### b) Assumindo desvios padr√µes diferentes (heterocedasticidade)

$$ SE_{unpooled} = \sqrt{ \frac{s_1^2}{n_1} + \frac{s_2^2}{n_2} } $$
```{r}
se_unpooled <- sqrt( (s1^2 / n1) + (s2^2 / n2) )

print(paste("Erro Padr√£o (N√£o Agrupado):", round(se_unpooled, 4)))
```

## Diferen√ßa de M√©dias Padronizadas

### O que √©?

A diferen√ßa de m√©dias padronizadas (SMD) expressa a diferen√ßa entre os grupos em unidades de desvios-padr√£o, e n√£o na unidade original de medida. Quando usar? √â essencial quando os estudos medem o mesmo desfecho (construto), mas usam escalas/instrumentos diferentes.

Exemplo Pr√°tico (Depress√£o): Voc√™ quer ver se Terapia Cognitiva Comportamental reduz depress√£o.Estudo A usou a Escala de Beck (BDI) (vai de 0 a 63).Estudo B usou a Escala de Hamilton (HAM-D) (vai de 0 a 50).N√£o podemos unir estudos que utilizam Beck com os que utilizam Hamilton sem fazer nenhum tratamento.

A solu√ß√£o √© padronizar! Esse procedimento que falamos acima sobre calcular a diferen√ßa baseada em unidades de desvio padr√£o √©, em outras palavras, calcular o Cohen's d. Por exemplo, se o resultado for $d = -0.5$, significa que o tratamento reduziu a depress√£o em "meio desvio padr√£o", independente da escala usada.

- **Interpreta√ß√£o Visual** (Sobreposi√ß√£o) O Cohen's d nos diz o quanto as curvas dos dois grupos se separaram:

$d = 0.2$ (Pequeno): Grande sobreposi√ß√£o entre os grupos (as curvas quase se tocam).

$d = 0.5$ (M√©dio): Separa√ß√£o vis√≠vel.

$d = 0.8$ (Grande): Clara separa√ß√£o entre tratado e controle.

```{r, echo = F, fig.width=10, fig.cap="Representa√ß√£o visual do d de Cohen. Perceba que quanto maior o seu valor, maior a separa√ß√£o entre os grupos. E, assim, consequemente, menor ser√° a √°rea de intersec√ß√£o entre as curvas. Por isso, que ele representa uma forma de quantificar a diferen√ßa entre grupos."}

cor_laranja <- "#E67E22"
cor_roxo    <- "#2980B9"
espessura_linha <- 2

# Tema limpo para remover eixos e adicionar a borda preta
theme_box <- theme_void() +
  theme(
    plot.margin = margin(10, 10, 10, 10),
    panel.border = element_rect(color = "black", fill = NA, size = 1.5), # A caixa preta
    plot.background = element_rect(fill = "white", color = NA) # Fundo branco limpo
  )

# --- 2. Fun√ß√£o para Gerar Cada Gr√°fico ---
plot_simple_cohen <- function(d) {
  
  # Sequ√™ncia do eixo X suficiente para cobrir as duas curvas
  x_range <- seq(-4, 4 + d, length.out = 1000)
  
  # Dados das duas curvas normais
  df <- data.frame(
    x = x_range,
    y_controle = dnorm(x_range, mean = 0, sd = 1),
    y_tratado  = dnorm(x_range, mean = d, sd = 1)
  )
  
  # Criar o plot
  p <- ggplot(df, aes(x = x)) +
    # Linha Laranja (Controle, M√©dia 0)
    geom_line(aes(y = y_controle), color = cor_laranja, size = espessura_linha) +
    # Linha Roxa (Tratado, M√©dia d)
    geom_line(aes(y = y_tratado), color = cor_roxo, size = espessura_linha) +
    
    # R√≥tulo no canto superior esquerdo
    # Posicionamos fixo em x=-3 e y=0.35 para ficar no canto
    annotate("text", x = -3.2, y = 0.35, label = paste0("d=", d), 
             hjust = 0, size = 8, fontface = "plain") +
    
    # Aplicar o tema limpo com borda
    theme_box +
    # Fixar limites para garantir que o texto fique sempre no mesmo lugar relativo
    coord_cartesian(xlim = c(-3.5, 3.5 + d), ylim = c(0, 0.42), expand = FALSE)

  return(p)
}

# --- 3. Gerar os 4 Gr√°ficos ---
p1 <- plot_simple_cohen(0.5)
p2 <- plot_simple_cohen(1)
p3 <- plot_simple_cohen(2)
p4 <- plot_simple_cohen(3)

# --- 4. Combinar em Grid 2x2 ---
# Usamos patchwork para juntar tudo
final_plot <- (p1 + p2) / (p3 + p4)

# Exibir
print(final_plot)
```


### Erro Padr√£o

#### a) F√≥rmula Mais Comum (Homocedasticidade)

Essa f√≥rmula para o c√°lculo do d de Cohen utiliza o desvio padr√£o agrupado. E, como falamos antes, ele assume que ambos os desvios padr√µes s√£o iguais. Por√©m, essa f√≥rmula acaba sendo mais utilizada.

$$ d = \frac{\bar{x}_1 - \bar{x}_2}{s_{pooled}} $$

```{r}
# Instalar pacote se necess√°rio: install.packages("esc")
library(esc)

effect_size <- esc_mean_sd(
  grp1m = 15, grp1sd = 5, grp1n = 50,
  grp2m = 20, grp2sd = 5, grp2n = 50
)

# O resultado mostra o 'es' (Effect Size) d de Cohen
print(effect_size)
```

#### b) F√≥rmulas para Heterocedasticidade

Existem duas formas de calcular o d de Cohen assumindo que os desvios n√£o s√£o os mesmos. Podemos fazer uma m√©dia entre os dois.

$$ d = \frac{\bar{x}_1 - \bar{x}_2}{\sqrt{\frac{s_1^2 + s_2^2}{2}}} $$
Uma forma mais comum e segura de fazer isso √© utilizando uma m√©trica chamada Delta de Glass. Inv√©s de dividir pela m√©dia de dois desvios padr√µes, dividimos apenas pelo desvio do grupo controle. 

$$ \Delta_{\text{Glass}} = \frac{\bar{x}_1 - \bar{x}_2}{SD_{\text{controle}}} $$

Embora seja comum assumir vari√¢ncias iguais (Homocedasticidade) e usar o desvio padr√£o agrupado (Pooled) para calcular o d de Cohen, isso pode ser um erro se o tratamento alterar a variabilidade dos dados.

