---
title: "Tutorial em Constru√ß√£o"
description: |
  Tutorial em Constru√ß√£o em R.
output:
  distill::distill_article:
    highlight: pygments
    highlight_downlit: false
---

```{css, echo=FALSE}
h1, h2, h3, h4 {
  border-bottom: 1px solid #dddddd; /* Cria a linha cinza fina embaixo */
  padding-bottom: 12px;              /* Espa√ßo entre o texto e a linha */
  margin-bottom: 18px;              /* Espa√ßo depois da linha para o pr√≥ximo par√°grafo */
  margin-top: 28px;                 /* Espa√ßo antes do t√≠tulo */
```

```{r setup, include=FALSE}
library(tidyverse)
library(patchwork)
library(gridExtra)
library(cowplot)
library(grid)
```



# 1. Introdu√ß√£o

### 1.1. O que √© tamanho de efeito?

O tamanho de efeito √© uma m√©trica utilizada para quantificar a rela√ß√£o entre duas entidades, capturando tanto a dire√ß√£o quanto a magnitude desse fen√¥meno. Diferente de um simples teste de hip√≥tese (que diz se algo funcionou ou n√£o), o tamanho de efeito nos diz o quanto funcionou. Essencialmente, √© a moeda comum que permite comparar e combinar resultados de estudos diferentes em uma metan√°lise.

- **M√©dia Amostral**
  - Ex: "Qual √© a altura m√©dia de crian√ßas de 10 anos nesta popula√ß√£o espec√≠fica?"
  
- **Propor√ß√µes**
  - Ex: "Qual √© a preval√™ncia de burnout em profissionais de enfermagem que trabalham em UTI?"

- **Coeficiente de Correla√ß√£o** (ex: r de Pearson)
  - Ex: "Existe uma associa√ß√£o entre o n√≠vel de escolaridade dos pais e o sucesso acad√™mico dos filhos?" ‚Üí Ou seja, avaliar a rela√ß√£o de duas vari√°veis cont√≠nuas.

- **Diferen√ßa de M√©dias** (ex: Cohen's d, Hedges' g)
  - Ex: "O novo medicamento causa uma redu√ß√£o maior na press√£o arterial comparado ao grupo controle?" ‚Üí Ou seja, comparar grupos (Interven√ß√£o vs. Controle) usando uma vari√°vel.

- **Raz√£o de Chances ou Risco** (Odds Ratio / Risk Ratio)
  - Ex: "Fumantes t√™m maior probabilidade de desenvolver c√¢ncer de pulm√£o do que n√£o fumantes?" ‚Üí Ou seja, avaliar desfechos bin√°rios (Sim/N√£o, Doente/Saud√°vel, Vivo/Morto).


### 1.2. Entendendo Amostragem

#### a) Popula√ß√£o vs. Amostragem

Imagine que quis√©ssemos saber o n√≠vel m√©dio exato de Hemoglobina Glicada (HbA1c) de todos os pacientes diab√©ticos do mundo sob tratamento com um novo f√°rmaco.

Se tiv√©ssemos recursos infinitos, medir√≠amos a HbA1c de cada um desses milh√µes de pacientes. Ao final, ter√≠amos uma distribui√ß√£o com uma m√©dia exata (ex: 7,5%) e um desvio padr√£o exato. Na estat√≠stica, chamamos esses valores de Par√¢metros Populacionais. Eles representam a verdade biol√≥gica absoluta sobre aquele tratamento.

o mundo real, nunca temos tempo, dinheiro ou capacidade log√≠stica para medir a popula√ß√£o inteira. √â aqui que entra a ci√™ncia pr√°tica: n√≥s fazemos uma **Amostragem**.

Quando um pesquisador publica um Ensaio Cl√≠nico Randomizado (RCT) com 100 pacientes para testar esse f√°rmaco, ele est√° pegando apenas uma pequena fatia da popula√ß√£o global. Com base nos dados desses 100 pacientes, ele calcula uma m√©dia e um desvio padr√£o. Mas aten√ß√£o: estes n√£o s√£o os Par√¢metros Populacionais. Eles s√£o apenas Estimativas.

<br>

> **A Realidade Estat√≠stica**: √â extremamente improv√°vel que a m√©dia de HbA1c encontrada nesse estudo seja exatamente igual √† m√©dia real da popula√ß√£o mundial (7,5%). Sempre haver√° um erro aleat√≥rio.

<br>

#### b) Teorema do Limite Central: E se repet√≠ssemos a amostragem? 

O que aconteceria se, em vez de fazer apenas um estudo medindo a HbA1c de 100 pacientes, n√≥s repet√≠ssemos esse mesmo estudo 1.000 vezes? Ter√≠amos 1.000 m√©dias diferentes (7,2%, 7,1%, 7,5%, 7,3%...). Se colocarmos todas essas m√©dias em um gr√°fico (histograma), observaremos um fen√¥meno fascinante:

1. A maioria das m√©dias dos estudos vai se acumular em torno de um valor central.

2. Algumas poucas m√©dias (os estudos "azarados" ou extremos) ficar√£o mais afastadas.

```{r media_pop, echo = F}
set.seed(123)

# --- 1. Defini√ß√£o do Cen√°rio ---
mu_real <- 7.0      
sigma_real <- 1.0   
n_estudos <- 10     
n_pacientes <- 3    # N baixo para mostrar o caos

# --- 2. Gerar Dados ---
dados_amostras <- data.frame(
  estudo_id = rep(1:n_estudos, each = n_pacientes),
  hba1c = rnorm(n_estudos * n_pacientes, mean = mu_real, sd = sigma_real)
)

dados_resumo <- dados_amostras %>%
  group_by(estudo_id) %>%
  summarise(media_amostral = mean(hba1c))

# --- 3. Gr√°fico Superior (Popula√ß√£o) ---
x_range <- seq(mu_real - 4*sigma_real, mu_real + 4*sigma_real, length.out = 1000)
dados_populacao <- data.frame(
  x = x_range,
  y = dnorm(x_range, mean = mu_real, sd = sigma_real)
)
limites_x <- c(4, 10) 

plot_top <- ggplot(dados_populacao, aes(x = x, y = y)) +
  geom_area(fill = "grey90", color = "black", size = 0.8) +
  geom_vline(xintercept = mu_real, linetype = "dashed", size = 1, color = "#E74C3C") +
  labs(title = "Popula√ß√£o (Par√¢metro)", y = "", x = NULL) +
  scale_x_continuous(limits = limites_x) +
  theme_void() +
  theme(plot.title = element_text(hjust = 0.5, face = "bold", size = 16))

# --- 4. Gr√°fico Inferior (Amostras) ---
plot_bottom <- ggplot() +
  # A. Linha Vertical da Verdade
  geom_vline(xintercept = mu_real, linetype = "dashed", size = 0.8, color = "#E74C3C", alpha = 0.5) +
  
  # B. Linhas de ERRO (Setas)
  # Nota: Aqui usamos 'estudo_id' num√©rico direto no Y
  geom_segment(data = dados_resumo, 
               aes(x = media_amostral, xend = mu_real, 
                   y = estudo_id, yend = estudo_id),
               color = "red", linetype = "solid", size = 0.8, 
               arrow = arrow(length = unit(0.2, "cm"))) +
  
  # C. Pontos Brutos (Pacientes)
  geom_point(data = dados_amostras, 
             aes(x = hba1c, y = estudo_id), 
             color = "grey60", alpha = 0.8, size = 2) +
  
  # D. M√©dia da Amostra (Losango Azul)
  geom_point(data = dados_resumo, 
             aes(x = media_amostral, y = estudo_id), 
             shape = 18, size = 5, color = "blue") +
  
  # Est√©tica
  labs(x = "N√≠vel de HbA1c", y = "Estudo N¬∫") +
  
  # AQUI ESTAVA O PROBLEMA: Agora definimos explicitamente como cont√≠nuo, 
  # mas for√ßamos 'breaks' inteiros para parecerem linhas.
  scale_x_continuous(limits = limites_x) +
  scale_y_continuous(breaks = 1:n_estudos) + 
  
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major.y = element_line(color = "grey95"),
    panel.grid.minor = element_blank()
  )

# --- 5. Combinar ---
final_plot <- plot_top / plot_bottom + plot_layout(heights = c(1, 4))

print(final_plot)
```

Essa cole√ß√£o de m√©dias de v√°rios estudos hipot√©ticos cria o que chamamos de Distribui√ß√£o Amostral. Aqui entra uma das regras mais importantes da estat√≠stica para a metan√°lise. Voc√™ pode se perguntar: "E se os dados originais dos pacientes n√£o forem normais?" (Ex: tempo de interna√ß√£o hospitalar, que geralmente n√£o segue uma curva normal).

O **Teorema do Limite Central** afirma que, independentemente da distribui√ß√£o dos dados originais (seja uniforme, exponencial, etc.), se pegarmos as m√©dias dessas amostragens, a distribui√ß√£o dessas m√©dias ser√° sempre Normal (uma curva de sino).

```{r teorema, echo = F}
set.seed(42)

# --- 1. CORES E EST√âTICA ---
cor_pop_fill   <- "#FAE5D3"  
cor_pop_line   <- "#D35400"  
cor_samp_fill  <- "#D1F2EB"  
cor_samp_line  <- "#117864"  
cor_seta       <- "#F1C40F"  
cor_seta_baixo <- "#5DADE2"  

# Tema base limpo
theme_clean <- theme_classic() +
  theme(
    axis.line = element_line(color = "grey85"),
    axis.ticks = element_line(color = "grey85"),
    plot.title = element_text(hjust = 0.5, face = "bold", size = 12),
    axis.title = element_text(size = 10),
    plot.background = element_rect(fill = "white", color = NA),
    plot.margin = margin(t = 10, r = 10, b = 10, l = 10) 
  )

# --- 2. DADOS ---
populacao <- rexp(50000, rate = 0.8) 
df_pop <- data.frame(x = populacao)

# --- 3. GR√ÅFICO SUPERIOR ---
plot_pop <- ggplot(df_pop, aes(x = x)) +
  geom_histogram(bins = 40, fill = cor_pop_fill, color = cor_pop_line, size = 0.2) +
  labs(title = "Population", y = "Frequency", x = "") +
  scale_x_continuous(breaks = 0:8, limits = c(0, 8), expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) + 
  theme_clean

# --- 4. FUN√á√ÉO PARA OS GR√ÅFICOS DE BAIXO ---
criar_plot_amostra <- function(n, show_y_label = FALSE) {
  medias <- replicate(2000, mean(sample(populacao, n)))
  df_medias <- data.frame(m = medias)
  
  p <- ggplot(df_medias, aes(x = m)) +
    geom_histogram(bins = 30, fill = cor_samp_fill, color = cor_samp_line, size = 0.2) +
    # Mantendo X e Y com "ch√£o" no zero
    scale_x_continuous(limits = c(0, 4), breaks = c(0, 1, 2, 3, 4)) + 
    scale_y_continuous(expand = c(0, 0)) +
    theme_clean +
    theme(
      axis.text.x = element_text(size = 9, color = "grey30"), 
      # AQUI EST√Å A MUDAN√áA: Garante que o texto do eixo Y sempre apare√ßa
      axis.text.y = element_text(size = 8, color = "grey40"), 
      plot.margin = margin(t = 5, r = 8, b = 15, l = 5) # Ajuste leve na margem direita para os n√∫meros n√£o cortarem
    )
  
  # Condicional apenas para o T√çTULO do eixo ("Frequency"), n√£o para os n√∫meros
  if(show_y_label) {
    p <- p + labs(y = "Frequency", x = "")
  } else {
    p <- p + labs(y = "", x = "") 
  }
  return(p)
}

# Gerar os gr√°ficos (Todos agora ter√£o n√∫meros no eixo Y)
p5   <- criar_plot_amostra(5, show_y_label = TRUE)  # Este tem o t√≠tulo "Frequency"
p30  <- criar_plot_amostra(30, show_y_label = FALSE) # Este tem apenas n√∫meros
p100 <- criar_plot_amostra(100, show_y_label = FALSE) # Este tem apenas n√∫meros

# --- 5. MONTAGEM DO LAYOUT ---
# Usamos align = "h" e axis = "tb" para garantir que os eixos fiquem alinhados 
# mesmo com larguras de n√∫meros diferentes (ex: 500 vs 1000)
row_bottom <- plot_grid(
  p5, p30, p100, 
  nrow = 1, 
  align = "h", axis = "tb",
  labels = c("n=5", "n=30", "n=100"), 
  label_size = 11, 
  label_y = 0.02,   
  label_x = 0.5,    
  hjust = 0.5,
  vjust = 0         
)

grid_plots <- plot_grid(
  plot_pop, 
  row_bottom, 
  ncol = 1, 
  rel_heights = c(1, 1.3), 
  scale = 0.95             
)

# --- 6. SETAS E DETALHES FINAIS ---
final_plot <- ggdraw(grid_plots) +
  # Setas Superiores
  draw_line(x = c(0.40, 0.20), y = c(0.53, 0.42), color = cor_seta, size = 1.2, arrow = arrow(length = unit(0.25, "cm"), type = "closed")) +
  draw_line(x = c(0.5, 0.5), y = c(0.53, 0.42), color = cor_seta, size = 1.2, arrow = arrow(length = unit(0.25, "cm"), type = "closed")) +
  draw_line(x = c(0.60, 0.80), y = c(0.53, 0.42), color = cor_seta, size = 1.2, arrow = arrow(length = unit(0.25, "cm"), type = "closed")) +
  
  # Seta Inferior
  draw_line(x = c(0.05, 0.95), y = c(0.01, 0.01), color = cor_seta_baixo, size = 2, arrow = arrow(length = unit(0.4, "cm"), type = "closed"))

print(final_plot)
```

<br>

> **Por que isso importa na medicina?** N√£o precisamos nos preocupar tanto se a vari√°vel biol√≥gica original (como carga viral ) tem uma distribui√ß√£o estranha. Desde que tenhamos um n√∫mero amostral suficiente (geralmente acima de 30), podemos assumir que as m√©dias dos estudos que vamos combinar na metan√°lise se comportam como uma curva Normal.

<br>

#### c) Erro Padr√£o: Qu√£o precisa √© a m√©dia das amostragens?

Agora que sabemos que as m√©dias de v√°rios estudos formam uma curva, precisamos medir a "largura" dessa curva. √â aqui que muita gente confunde Desvio Padr√£o com Erro Padr√£o. Vamos diferenciar:

- **Desvio Padr√£o (SD)**: Mede o quanto UMA amostragem est√° espalhada. √â a varia√ß√£o biol√≥gica entre paciente e paciente (ex: o quanto a glicemia varia entre os sujeitos do estudo).

- **Erro Padr√£o (SE)**: Mede o quanto a m√©dia de v√°rias amostragens est√° espalhada. Ele √©, basicamente, o desvio padr√£o das m√©dias de v√°rios estudos.

```{r erro_pad, echo=F}
set.seed(42)

# --- 1. Par√¢metros do Diabetes (HbA1c) ---
mu_hba1c <- 7.0      # M√©dia Real
sigma_hba1c <- 1.0   # Desvio Padr√£o Real
n_amostra <- 30      # Tamanho de cada estudo

# C√°lculo do Erro Padr√£o Te√≥rico (Para desenhar a linha exata)
se_teorico <- sigma_hba1c / sqrt(n_amostra) # ~0.18

# --- 2. Simula√ß√£o ---
# 5000 estudos simulados
medias_simuladas <- replicate(5000, mean(rnorm(n_amostra, mean = mu_hba1c, sd = sigma_hba1c)))
df_sim <- data.frame(m = medias_simuladas)

# --- 3. C√°lculos de Posi√ß√£o para o Gr√°fico ---
# Descobrir a altura m√°xima da curva normal para posicionar a linha ACIMA dela
altura_max <- dnorm(mu_hba1c, mean = mu_hba1c, sd = se_teorico)
posicao_linha_y <- altura_max * 1.05  # 5% acima do pico
posicao_texto_y <- altura_max * 1.12  # Um pouco acima da linha

# --- 4. O Gr√°fico ---
ggplot(df_sim, aes(x = m)) +
  # A. Histograma (Dados Simulados)
  geom_histogram(aes(y = ..density..), bins = 50, 
                 fill = "#D1F2EB", color = "white", alpha = 0.8) +
  
  # B. Curva Normal Te√≥rica (O "Sino")
  stat_function(fun = dnorm, args = list(mean = mu_hba1c, sd = se_teorico),
                color = "#117864", size = 1.2) +
  
  # C. Linha Central (M√©dia) - Tracejada at√© o topo
  geom_segment(aes(x = mu_hba1c, xend = mu_hba1c, y = 0, yend = posicao_linha_y), 
               linetype = "dashed", color = "grey60", size = 0.8) +
  
  # D. A Linha Horizontal do Erro Padr√£o (Sim√©trica: Esquerda e Direita)
  # Vai de (M√©dia - SE) at√© (M√©dia + SE)
  geom_segment(aes(x = mu_hba1c - se_teorico, xend = mu_hba1c + se_teorico, 
                   y = posicao_linha_y, yend = posicao_linha_y),
               color = "#E74C3C", size = 1.2) +
  
  # E. Pontas da linha (para parecer uma r√©gua de medida |---|)
  geom_segment(aes(x = mu_hba1c - se_teorico, xend = mu_hba1c - se_teorico,
                   y = posicao_linha_y - 0.05, yend = posicao_linha_y + 0.05),
               color = "#E74C3C", size = 1.2) +
  geom_segment(aes(x = mu_hba1c + se_teorico, xend = mu_hba1c + se_teorico,
                   y = posicao_linha_y - 0.05, yend = posicao_linha_y + 0.05),
               color = "#E74C3C", size = 1.2) +

  # F. R√≥tulo
  annotate("text", x = mu_hba1c, y = posicao_texto_y, 
           label = "Erro Padr√£o (SE)", color = "#E74C3C", fontface = "bold", size = 5) +
  
  # Est√©tica Limpa
  labs(x = "M√©dia de HbA1c (%)", y = "Densidade") +
  scale_x_continuous(breaks = seq(6, 8, 0.2)) + # Escala focada nos valores de HbA1c
  scale_y_continuous(expand = expansion(mult = c(0, 0.2))) + # Mais espa√ßo no topo para o texto
  theme_classic(base_size = 14) +
  theme(
    axis.line.y = element_blank(), # Remove eixo Y para ficar mais limpo
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank()
  )
```

**Conceito Chave**: O Erro Padr√£o √© uma medi√ß√£o do qu√£o representativas s√£o nossas amostragens em rela√ß√£o √† popula√ß√£o.

- **Alto Erro Padr√£o**: As m√©dias dos estudos variam muito entre si. O estudo √© pouco preciso.

- **Baixo Erro Padr√£o**: As m√©dias variam pouco. O estudo √© uma boa representa√ß√£o da popula√ß√£o.

```{r se_tamanho_amostral, echo=F}
# Simular o comportamento do Erro Padr√£o
n_vals <- seq(5, 200, by = 5)
sd_fixo <- 15 # Vamos supor um desvio padr√£o fixo de 15 unidades (ex: press√£o arterial)

df_erro <- data.frame(
  n = n_vals,
  se = sd_fixo / sqrt(n_vals) # A f√≥rmula m√°gica
)

g3 <- ggplot(df_erro, aes(x = n, y = se)) +
  # Linha da tend√™ncia
  geom_line(color = "#E74C3C", size = 1.5) +
  scale_y_continuous(expand = c(0, 0), limits = c(0, 10)) +
  # Pontos para marcar os steps
  geom_point(size = 3, color = "#C0392B") +
  # √Årea sombreada para dar ideia de redu√ß√£o da incerteza
  geom_area(fill = "#E74C3C", alpha = 0.2) +
  labs(
    x = "Tamanho da Amostra (n)",
    y = "Erro Padr√£o (SE)"
  ) +
  theme_classic(base_size = 14) +
  scale_x_continuous(expand = c(0, 0), limits = c(5, NA), breaks = seq(0, 200, 50))

print(g3)
```

*Nota: O Erro Padr√£o ser√° sempre menor que o Desvio Padr√£o, pois as m√©dias s√£o naturalmente menos dispersas do que as observa√ß√µes individuais.*

```{r se_largura, echo=F}
library(ggplot2)
library(dplyr)
library(patchwork)

set.seed(123)

# 1. Simular uma Popula√ß√£o "Real" (ex: 100.000 pacientes)
# Usaremos uma distribui√ß√£o Gamma para dar uma leve assimetria (comum em biologia)
# M√©dia aprox 7.0, mas com cauda longa
populacao <- rgamma(100000, shape = 15, scale = 0.5) 
media_real <- mean(populacao)
sd_pop <- sd(populacao)

# 2. Simular a "Amostragem Repetida" (O exerc√≠cio mental da Metan√°lise)
# Vamos pegar 1.000 amostras de 30 pacientes cada e tirar a m√©dia
n_amostra <- 30
n_simulacoes <- 1000

medias_amostrais <- replicate(n_simulacoes, {
  amostra <- sample(populacao, n_amostra)
  mean(amostra)
})

# Preparar dados para plotar
df_pop <- data.frame(valor = populacao, tipo = "Popula√ß√£o (Pacientes Individuais)")
df_medias <- data.frame(valor = medias_amostrais, tipo = "Distribui√ß√£o das M√©dias (Estudos)")

# GR√ÅFICO 1: A Compara√ß√£o
g1 <- ggplot() +
  # Curva da Popula√ß√£o (Fundo, cinza)
  geom_density(data = df_pop, aes(x = valor, fill = "Popula√ß√£o"), 
               alpha = 0.4, color = "grey40") +
  # Curva das M√©dias (Frente, destaque)
  geom_density(data = df_medias, aes(x = valor, fill = "M√©dias dos Estudos"), 
               alpha = 0.7, color = "darkblue") +
  # Linha da M√©dia Real
  geom_vline(xintercept = media_real, linetype = "dashed", size = 1) +
  # Decora√ß√£o
  scale_fill_manual(values = c("Popula√ß√£o" = "#999999", "M√©dias dos Estudos" = "#2E86C1"), name = "") +
  labs(
    x = "N√≠vel de HbA1c (%)",
    y = "Densidade"
  ) +
  theme_minimal(base_size = 14) +
  theme(legend.position = "bottom") +
  annotate("text", x = 10, y = 0.2, label = "Desvio Padr√£o (SD)\n√© a largura desta curva", color = "grey30", hjust=0) +
  annotate("text", x = 8.5, y = 1.5, label = "Erro Padr√£o (SE)\n√© a largura desta curva", color = "#2E86C1", hjust=0, fontface="bold")

print(g1)
```


<br>

#### d) Erro Padr√£o: E se eu tiver apenas um estudo?

Voc√™ deve estar pensando: "Mas eu s√≥ tenho UM estudo em m√£os, eu n√£o repeti a amostragem 1.000 vezes. Como eu descubro o Erro Padr√£o?"

A estat√≠stica nos d√° um atalho. √â poss√≠vel estimar o erro padr√£o tendo apenas uma amostragem (o estudo que voc√™ est√° lendo). Existe uma "F√≥rmula Especial" para o Erro Padr√£o da M√©dia:

$$SE = \frac{s}{\sqrt{n}}$$

Onde:

- $\sigma$ = Desvio Padr√£o (do estudo).

- $n$ = Tamanho da amostra (n√∫mero de pacientes).

> **Interpreta√ß√£o para Metan√°lise**: Olhe para a f√≥rmula. O $n$ est√° no denominador. Isso prova matematicamente que quanto maior o n√∫mero de pacientes ($n$), menor ser√° o erro padr√£o ($SE$).Na metan√°lise, estudos com $SE$ menor (mais precisos) ganhar√£o mais peso na decis√£o final.

<br>


## 2. M√©tricas Comuns

### 2.1. M√©dia Aritm√©trica

A m√©dia aritm√©tica √© uma das medidas de tend√™ncia central poss√≠veis de serem utilizadas em metan√°lises. Ela deve ser necessariamente utilizada quando todos os estudos utilizam a mesma m√©trica e n√£o h√° um grupo controle. Por exemplo, para investigar a altura m√©dia de uma popula√ß√£o. 

Ela √© calculada da seguinte forma:

$$ \bar{x} = \frac{\sum_{i=1}^{n} x_i}{n} $$

```{r media}
# Definir semente para reprodutibilidade
set.seed(100)

# Gerar uma amostra aleat√≥ria (n=50) com m√©dia 20 e desvio padr√£o 5
sample <- rnorm(n = 50, mean = 20, sd = 5)

# Calcular a m√©dia
media_calculada <- mean(sample)
print(paste("M√©dia:", media_calculada))
```

<br>

N√≥s j√° falamos sobre como calcular o erro padr√£o da m√©dia. Mas aqui est√° relembrando para voc√™!

$$ SE_{\bar{x}} = \frac{s}{\sqrt{n}} $$

```{r se_media}
# Calcular o Erro Padr√£o (SD dividido pela raiz quadrada de n)
erro_padrao <- sd(sample) / sqrt(50)
print(paste("Erro Padr√£o:", erro_padrao))
```

Para conduzir uma metan√°lise de m√©dias, seu banco de dados precisa obrigatoriamente conter tr√™s informa√ß√µes (colunas) de cada estudo inclu√≠do:

- $n$: O tamanho da amostra (n√∫mero de observa√ß√µes).
- $mean$: A m√©dia relatada no estudo.
- $sd$: O desvio padr√£o da vari√°vel.

### 2.2. Propor√ß√µes

A propor√ß√£o √© uma medida de tend√™ncia central que especifica quantas unidades de uma amostra pertencem a um subgrupo espec√≠fico (ex: preval√™ncia de uma doen√ßa). Novamente, trata-se de uma medida em que n√£o h√° compara√ß√£o de grupos. Ela varia entre 0 e 1 e √© calculada dividindo o n√∫mero de eventos ($k$) pelo tamanho total da amostra ($n$).

A propor√ß√£o √© calculada como:

$$ p = \frac{k}{n} $$

```{r prop}
# Definir valores: k (eventos) e n (total)
k <- 50
n <- 200

# C√°lculo da Propor√ß√£o Bruta 
p <- k / n
print(paste("Propor√ß√£o (p):", p))

```


O erro padr√£o da propor√ß√£o √© calculado como: 

$$ SE_p = \sqrt{\frac{p(1-p)}{n}} $$
```{r prop_se}
# Erro Padr√£o da Propor√ß√£o
se_p <- sqrt((p * (1 - p)) / n)
print(paste("Erro Padr√£o (Raw):", se_p))
```


#### a) O problema dos extremos

Como a propor√ß√£o √© limitada entre 0 e 1, surgem problemas quando o valor de $p$ √© muito pr√≥ximo de 0 ou de 1.

- **Erro Padr√£o Comprimido**: O erro padr√£o √© artificialmente reduzido, levando a uma superestima√ß√£o da precis√£o.
- **Distribui√ß√£o Assim√©trica**: A distribui√ß√£o amostral deixa de ser normal (Sino) e torna-se enviesada (*skewed*) √† esquerda ou direita, pois √© imposs√≠vel ter valores fora do intervalo 0-1.

<br>

```{r, echo=F, message=FALSE}
# --- CONFIGURA√á√ÉO EST√âTICA ---
cor_raw   <- "#E67E22" # Laranja (Propor√ß√£o Bruta)
cor_logit <- "#2980B9" # Azul (Logit)
theme_set(theme_minimal(base_size = 12))

# ==============================================================================
# PARTE 1: SIMULA√á√ÉO DA DISTRIBUI√á√ÉO (SKEWNESS / ASSIMETRIA)
# ==============================================================================

set.seed(42)
n_sim <- 10000    # N√∫mero de estudos simulados
n_sample <- 300   # Tamanho da amostra pequeno/m√©dio
p_real <- 0.95   # Propor√ß√£o EXTREMA (perto de 1.0)

# 1. Gerar os dados
# rbinom gera o n√∫mero de sucessos (k)
sim_k <- rbinom(n_sim, size = n_sample, prob = p_real)
sim_p <- sim_k / n_sample

# 2. Filtrar 0 e 1 puros para o Logit n√£o dar Infinito (limita√ß√£o matem√°tica)
validos <- sim_p > 0 & sim_p < 1
sim_p_clean <- sim_p[validos]

# 3. Transformar para Logit
sim_logit <- log(sim_p_clean / (1 - sim_p_clean))

# DF para plotagem
df_dist <- data.frame(
  type = c(rep("Propor√ß√£o Bruta (p)", length(sim_p_clean)), 
           rep("Transforma√ß√£o Logit", length(sim_logit))),
  value = c(sim_p_clean, sim_logit)
)

# --- Gr√°fico 1.A: A Assimetria (Skewed) ---
p1a <- ggplot(data.frame(x = sim_p_clean), aes(x = x)) +
  geom_histogram(aes(y = ..density..), bins = 100, fill = cor_raw, color = "white", alpha=0.8) +
  geom_density(color = "#D35400", size = 1) +
  geom_vline(xintercept = 1.0, linetype = "dashed", color = "black") +
  scale_x_continuous(limits = c(0.5,1)) + 
  labs(title = "1. Propor√ß√£o Bruta (p)", 
       subtitle = paste0("Popula√ß√£o p=", p_real, ". Note o 'pared√£o' no 1.0.\nA cauda se estica para a esquerda (Enviesada)."),
       x = "Propor√ß√£o Estimada", y = "Densidade")

# --- Gr√°fico 1.B: A Normaliza√ß√£o (Logit) ---
p1b <- ggplot(data.frame(x = sim_logit), aes(x = x)) +
  geom_histogram(aes(y = ..density..), bins = 20, fill = cor_logit, color = "white", alpha=0.8) +
  geom_density(color = "#1F618D", size = 1) +
  labs(title = "2. Ap√≥s Transforma√ß√£o Logit", 
       subtitle = "O espa√ßo √© 'esticado'.\nA distribui√ß√£o recupera a forma de sino (Normal).",
       x = "Logit Value", y = "Densidade")

# ==============================================================================
# PARTE 2: A COMPRESS√ÉO DO ERRO PADR√ÉO (PRECIS√ÉO ARTIFICIAL)
# ==============================================================================

# Vamos criar uma sequ√™ncia de p de 0.01 at√© 0.99
seq_p <- seq(0.01, 0.99, length.out = 200)
n_fixo <- 100

# F√≥rmulas de Erro Padr√£o
se_raw <- sqrt((seq_p * (1 - seq_p)) / n_fixo)
se_logit <- sqrt(1/(n_fixo * seq_p) + 1/(n_fixo * (1 - seq_p)))

df_se <- data.frame(
  p = seq_p,
  se_raw = se_raw,
  se_logit = se_logit
)

# --- Gr√°fico 2.A: O Problema (Compress√£o) ---
p2a <- ggplot(df_se, aes(x = p, y = se_raw)) +
  geom_line(color = cor_raw, size = 1.5) +
  geom_area(fill = cor_raw, alpha = 0.2) +
  annotate("text", x = 0.5, y = 0.052, label = "M√°ximo Erro\n(p=0.5)", color = "grey30") +
  annotate("text", x = 0.9, y = 0.02, label = "Erro 'Falso'\nBaixo", fontface="bold", color = "#D35400") +
  labs(title = "3. Erro Padr√£o da Propor√ß√£o (SE p)", 
       subtitle = "O erro diminui nas pontas. Isso finge que temos\nmuita certeza s√≥ porque p √© extremo.",
       x = "Valor de p", y = "Tamanho do Erro (SE)") +
  scale_y_continuous(limits = c(0, 0.06))
  scale_x_continuous(limits = c(0, 0.06))

# --- Gr√°fico 2.B: A Solu√ß√£o (Expans√£o) ---
p2b <- ggplot(df_se, aes(x = p, y = se_logit)) +
  geom_line(color = cor_logit, size = 1.5) +
  geom_area(fill = cor_logit, alpha = 0.2) +
  annotate("text", x = 0.9, y = 0.5, label = "Erro Real\nAlto", fontface="bold", color = "#1F618D") +
  labs(title = "4. Erro Padr√£o do Logit (SE logit)", 
       subtitle = "O erro explode nas pontas.\nReflete a real dificuldade de estimar extremos.",
       x = "Valor de p", y = "Tamanho do Erro (SE)")

p1a + p2a
```


#### b) A solu√ß√£o üòÅ

Para corrigir isso em metan√°lises, utilizamos a transforma√ß√£o em log natural - chamada de **logit**. Ela remove a restri√ß√£o de intervalo 0-1, garantindo que a distribui√ß√£o amostral seja aproximadamente normal e os erros padr√£o n√£o sejam enviesados.

A transforma√ß√£o da propor√ß√£o para logit da propor√ß√£o:

$$ p_{\text{logit}} = \log_e \left( \frac{p}{1-p} \right) $$


```{r}
# O logit transforma o intervalo 0-1 em -inf a +inf
p_logit <- log(p / (1 - p))
print(paste("Propor√ß√£o Transformada (Logit):", p_logit))
```

O erro padr√£o do logit da propor√ß√£o:

$$ SE_{p_{\text{logit}}} = \sqrt{\frac{1}{np} + \frac{1}{n(1-p)}} $$

```{r logit_prop}
se_logit <- sqrt((1 / (n * p)) + (1 / (n * (1 - p))))
print(paste("Erro Padr√£o (Logit):", se_logit))
```

<br>

```{r, echo=F}
p1b + p2b
```

Para conduzir uma metan√°lise de m√©dias, seu banco de dados precisa obrigatoriamente conter duas informa√ß√µes (colunas) de cada estudo inclu√≠do:

- $event$: O n√∫mero de observa√ß√µes no subgrupo espec√≠fico ($k$).
- $n$: O tamanho total da amostra.